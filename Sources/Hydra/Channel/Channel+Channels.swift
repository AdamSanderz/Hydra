//
//  Channel+Operations.swift
//  Hydra-iOS
//
//  Created by danielemargutti on 28/02/2018.
//  Copyright Â© 2018 Hydra. All rights reserved.
//

import Foundation

public extension Channel {
	
	/// Merge an array of channels into a single one.
	/// If list of channel is empty `self` channel is returned without changes.
	/// The first error, if any, generated by any channel put created channel in error state.
	/// Created channel will ends w
	///
	/// - Parameter channels: channels to merge.
	/// - Returns: merged channel.
	public func merge(_ channels: [Channel<Value,Error>]) -> Channel<Value,Error> {
		
		guard channels.count > 0 else {
			// invalid number of signals to merge, return the same unchanged channel.
			return self.asChannel()
		}
		
		return Channel({ producer in
			// Create a disposable bag which manages all disposables
			// generated by the subscription of each channel we want to merge.
			let bag = DisposableBag()
			var completionsCount: Int = channels.count
			// enumerate and subscribe each singla you want to merge
			channels.enumerated().forEach({ (idx,channel) in
				let channelDisposable = channel.subscribe({ event in
					switch event {
					case .next(let value):
						producer.send(value: value)
					case .error(let error):
						producer.send(error: error)
					case .finished:
						// If a subscriber finish its stream of data we want to
						// decrease the final counter (this because final event
						// can be sent only one time); once completionsCount is zero
						// we can send completition to the new merged channel.
						completionsCount -= 1
						if completionsCount == 0 {
							producer.complete()
						}
					}
				})
				bag.insert(channelDisposable)
			})
			
			return bag
		})
	}
	
	/// Create a channel which is a concatenation of `self` and another specified channel
	/// which dispatch the same type of values.
	/// If one source channel fails all channel fails.
	/// The result is channel which dispatch first all events from `self` then all events
	/// from the other channel.
	///
	/// - Parameter channel: channel to concatenate.
	/// - Returns: channel
	public func concat(to channel: Channel<Value,Error>) -> Channel<Value,Error> {
		return Channel({ producer in
			
			// We need to dispose both the subscription to `self` channel and the
			// other subscription created once the first one is finished.
			// Both of them will be disposed if we dispose the global one.
			var currentDisposable: DisposableProtocol? = nil
			currentDisposable = self.subscribe({ event in
				switch event {
				case .next(let value):
					producer.send(value: value)
				case .error(let error):
					producer.send(error: error)
				case .finished:
					// First source is finished, attach a new subscription to the
					// concatenated channel and get its disposable.
					currentDisposable = channel.subscribe(producer.send)
				}
			})
			
			return Disposable.onDispose({
				currentDisposable?.dispose()
			})
		})
	}
	
}
